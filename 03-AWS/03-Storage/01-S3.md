# Amazon S3 (Simple Storage Service)

## Overview

```
S3 = Object Storage with unlimited scale

Key Characteristics:
- Object storage (not file/block)
- 11 9s durability (99.999999999%)
- Unlimited storage capacity
- Max object size: 5 TB
- Max single PUT: 5 GB (use multipart for larger)
- Global namespace (bucket names globally unique)

Object Structure:
┌─────────────────────────────────────────────────────────────────────────┐
│  Bucket: my-bucket                                                       │
│  └── Key: folder/subfolder/file.txt                                     │
│      ├── Data (bytes)                                                   │
│      ├── Metadata (system + user-defined)                               │
│      └── Version ID (if versioning enabled)                             │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Storage Classes

### Comparison

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        S3 Storage Classes                                │
├─────────────────────┬─────────┬──────────┬─────────────┬───────────────┤
│ Class               │ Cost/GB │ Retrieval│ Availability│ Use Case      │
├─────────────────────┼─────────┼──────────┼─────────────┼───────────────┤
│ Standard            │ $0.023  │ Instant  │ 99.99%      │ Frequent      │
│ Intelligent-Tiering │ $0.023+ │ Instant  │ 99.9%       │ Unknown       │
│ Standard-IA         │ $0.0125 │ Instant  │ 99.9%       │ Infrequent    │
│ One Zone-IA         │ $0.01   │ Instant  │ 99.5%       │ Reproducible  │
│ Glacier Instant     │ $0.004  │ ms       │ 99.9%       │ Archive+quick │
│ Glacier Flexible    │ $0.0036 │ min-hrs  │ 99.99%      │ Archive       │
│ Glacier Deep Archive│ $0.00099│ 12+ hrs  │ 99.99%      │ Compliance    │
└─────────────────────┴─────────┴──────────┴─────────────┴───────────────┘

Minimum Storage Duration Charges:
- Standard-IA: 30 days
- One Zone-IA: 30 days
- Glacier Instant: 90 days
- Glacier Flexible: 90 days
- Glacier Deep Archive: 180 days
```

### Intelligent-Tiering

```
Automatic cost optimization:

┌─────────────────────────────────────────────────────────────────────────┐
│                    Intelligent-Tiering Tiers                             │
├─────────────────────┬───────────────────────────────────────────────────┤
│ Frequent Access     │ Objects accessed in last 30 days                  │
│ Infrequent Access   │ Not accessed for 30 days (40% savings)           │
│ Archive Instant     │ Not accessed for 90 days (68% savings) [opt-in]  │
│ Archive Access      │ Not accessed for 90-730 days [opt-in]            │
│ Deep Archive        │ Not accessed for 180-730 days [opt-in]           │
└─────────────────────┴───────────────────────────────────────────────────┘

Best for:
- Unknown or changing access patterns
- No retrieval fees
- Small monitoring fee per object
```

---

## Lifecycle Policies

### Configuration

```json
{
  "Rules": [
    {
      "ID": "Move to IA after 30 days",
      "Status": "Enabled",
      "Filter": {
        "Prefix": "logs/"
      },
      "Transitions": [
        {
          "Days": 30,
          "StorageClass": "STANDARD_IA"
        },
        {
          "Days": 90,
          "StorageClass": "GLACIER"
        },
        {
          "Days": 365,
          "StorageClass": "DEEP_ARCHIVE"
        }
      ],
      "Expiration": {
        "Days": 2555
      },
      "NoncurrentVersionTransitions": [
        {
          "NoncurrentDays": 30,
          "StorageClass": "GLACIER"
        }
      ],
      "NoncurrentVersionExpiration": {
        "NoncurrentDays": 90
      }
    }
  ]
}
```

### Common Patterns

```
Log Retention Pattern:
Day 0-30:    Standard (active analysis)
Day 30-90:   Standard-IA (occasional access)
Day 90-365:  Glacier Flexible (compliance)
Day 365+:    Delete or Deep Archive

Media Asset Pattern:
Day 0-7:     Standard (editing/processing)
Day 7-90:    Standard-IA (review)
Day 90+:     Glacier Instant (archive with quick access)

Backup Pattern:
Day 0-30:    Standard (fast restore)
Day 30-90:   Glacier Instant (quick recovery)
Day 90-365:  Glacier Flexible (disaster recovery)
Day 365+:    Deep Archive (compliance/legal)
```

---

## Versioning & Replication

### Versioning

```
Versioning States:
1. Unversioned (default)
2. Versioning-Enabled
3. Versioning-Suspended (keeps existing versions)

With Versioning:
┌─────────────────────────────────────────────────────────────────────────┐
│  Key: report.pdf                                                         │
│                                                                          │
│  Version ID: abc123 (current)  ←── Latest version                       │
│  Version ID: xyz789 (previous)                                          │
│  Version ID: def456 (previous)                                          │
│                                                                          │
│  Delete operation creates "delete marker" (new current version)         │
│  To truly delete: specify version ID                                    │
└─────────────────────────────────────────────────────────────────────────┘

MFA Delete:
- Requires MFA to delete versions or change versioning state
- Only root account can enable
- Extra protection for critical data
```

### Replication

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Replication Types                                   │
├────────────────────┬────────────────────────────────────────────────────┤
│ CRR (Cross-Region) │ Replicate to different region                      │
│                    │ Use: DR, compliance, latency reduction             │
├────────────────────┼────────────────────────────────────────────────────┤
│ SRR (Same-Region)  │ Replicate within same region                       │
│                    │ Use: Log aggregation, prod/test sync              │
└────────────────────┴────────────────────────────────────────────────────┘

Requirements:
- Versioning enabled on source AND destination
- IAM role for S3 to assume
- Buckets can be in different accounts

Replication Options:
- Entire bucket or prefix/tag filter
- Replicate delete markers (optional)
- Replica modification sync
- Replication Time Control (RTC) - 15 min SLA
```

---

## Security

### Access Control Layers

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     S3 Access Control                                    │
├─────────────────────────────────────────────────────────────────────────┤
│  Layer 1: Block Public Access (account or bucket level)                 │
│           └── BlockPublicAcls, IgnorePublicAcls                        │
│           └── BlockPublicPolicy, RestrictPublicBuckets                  │
├─────────────────────────────────────────────────────────────────────────┤
│  Layer 2: Bucket Policy (resource-based)                                │
│           └── Who can access this bucket                                │
├─────────────────────────────────────────────────────────────────────────┤
│  Layer 3: IAM Policy (identity-based)                                   │
│           └── What this identity can access                             │
├─────────────────────────────────────────────────────────────────────────┤
│  Layer 4: ACLs (legacy, avoid using)                                    │
│           └── Object-level permissions                                  │
├─────────────────────────────────────────────────────────────────────────┤
│  Layer 5: Access Points (simplified access management)                  │
│           └── Named network endpoints with policies                     │
└─────────────────────────────────────────────────────────────────────────┘
```

### Bucket Policy Examples

```json
// Allow public read (use cautiously)
{
  "Version": "2012-10-17",
  "Statement": [{
    "Sid": "PublicRead",
    "Effect": "Allow",
    "Principal": "*",
    "Action": "s3:GetObject",
    "Resource": "arn:aws:s3:::my-bucket/*"
  }]
}

// Cross-account access
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": {
      "AWS": "arn:aws:iam::ACCOUNT-B:root"
    },
    "Action": ["s3:GetObject", "s3:PutObject"],
    "Resource": "arn:aws:s3:::my-bucket/*"
  }]
}

// Enforce encryption
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Deny",
    "Principal": "*",
    "Action": "s3:PutObject",
    "Resource": "arn:aws:s3:::my-bucket/*",
    "Condition": {
      "StringNotEquals": {
        "s3:x-amz-server-side-encryption": "aws:kms"
      }
    }
  }]
}

// Require HTTPS
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Deny",
    "Principal": "*",
    "Action": "s3:*",
    "Resource": [
      "arn:aws:s3:::my-bucket",
      "arn:aws:s3:::my-bucket/*"
    ],
    "Condition": {
      "Bool": {
        "aws:SecureTransport": "false"
      }
    }
  }]
}
```

### Encryption

```
Encryption Options:
┌─────────────────────────────────────────────────────────────────────────┐
│ Server-Side Encryption (SSE)                                             │
├─────────────────────┬───────────────────────────────────────────────────┤
│ SSE-S3              │ S3 managed keys (AES-256)                         │
│                     │ Default, no additional cost                        │
├─────────────────────┼───────────────────────────────────────────────────┤
│ SSE-KMS             │ KMS managed keys                                   │
│                     │ Key rotation, audit trail, separate permissions   │
├─────────────────────┼───────────────────────────────────────────────────┤
│ SSE-C               │ Customer-provided keys                             │
│                     │ You manage keys, S3 encrypts                      │
├─────────────────────┼───────────────────────────────────────────────────┤
│ Client-Side         │ Encrypt before upload                             │
│                     │ Full control, more complex                        │
└─────────────────────┴───────────────────────────────────────────────────┘

Default Encryption:
- Enable at bucket level
- All new objects encrypted automatically
- Use SSE-S3 or SSE-KMS

Bucket Keys (for SSE-KMS):
- Reduces KMS request costs by up to 99%
- S3 generates bucket-level key
- Fewer calls to KMS
```

---

## Performance Optimization

### Multipart Upload

```
When to use:
- Objects > 100 MB (recommended)
- Objects > 5 GB (required)

Benefits:
- Parallel uploads (improved throughput)
- Pause and resume
- Quick recovery from failures

Process:
1. Initiate multipart upload
2. Upload parts in parallel (5MB - 5GB each)
3. Complete multipart upload
4. S3 assembles parts

// AWS SDK automatically handles multipart
aws s3 cp large-file.zip s3://bucket/ --expected-size 10GB
```

### Transfer Acceleration

```
S3 Transfer Acceleration:
┌─────────────────────────────────────────────────────────────────────────┐
│  Client ──→ Edge Location ──→ AWS Backbone ──→ S3 Bucket               │
│            (closest)         (optimized)       (any region)            │
└─────────────────────────────────────────────────────────────────────────┘

- Uses CloudFront edge locations
- 50-500% faster for long distances
- Additional cost ($0.04-$0.08/GB)
- Use endpoint: bucket.s3-accelerate.amazonaws.com

Best for:
- Users uploading from far away
- Large files over internet
- Variable upload speeds
```

### Request Performance

```
S3 Performance:
- 3,500 PUT/COPY/POST/DELETE per prefix per second
- 5,500 GET/HEAD per prefix per second

Optimization Strategies:

1. Prefix Distribution (old approach)
   bucket/2024/01/15/file1.txt  ← same prefix = shared limit
   bucket/2024/01/15/file2.txt

   Better:
   bucket/abc123/2024/01/15/file1.txt
   bucket/xyz789/2024/01/15/file2.txt

2. Use CloudFront for reads
   - Cache frequently accessed objects
   - Reduce S3 requests

3. Byte-Range Fetches
   - Download specific parts of objects
   - Parallel downloads of large files
```

---

## Event Notifications

### Configuration

```
S3 Events → Destinations:
┌─────────────────────────────────────────────────────────────────────────┐
│  S3 Bucket                                                               │
│     │                                                                    │
│     ├──→ SNS Topic (fan-out)                                            │
│     ├──→ SQS Queue (decoupling)                                         │
│     ├──→ Lambda Function (processing)                                   │
│     └──→ EventBridge (routing, filtering)                               │
└─────────────────────────────────────────────────────────────────────────┘

Event Types:
- s3:ObjectCreated:* (Put, Post, Copy, CompleteMultipartUpload)
- s3:ObjectRemoved:* (Delete, DeleteMarkerCreated)
- s3:ObjectRestore:* (Post, Completed)
- s3:Replication:* (OperationFailedReplication, etc.)
- s3:LifecycleTransition
- s3:IntelligentTiering
```

### Example: Image Processing Pipeline

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Upload    │───▶│  S3 Event   │───▶│   Lambda    │───▶│  Processed  │
│  (images/)  │    │ ObjectCreated│   │  (resize)   │    │ (thumbnails/)│
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘

// Lambda triggered by S3 event
{
  "LambdaFunctionConfigurations": [{
    "LambdaFunctionArn": "arn:aws:lambda:...:resize-function",
    "Events": ["s3:ObjectCreated:*"],
    "Filter": {
      "Key": {
        "FilterRules": [{
          "Name": "prefix",
          "Value": "images/"
        }, {
          "Name": "suffix",
          "Value": ".jpg"
        }]
      }
    }
  }]
}
```

---

## Static Website Hosting

### Configuration

```
S3 Static Website:
┌─────────────────────────────────────────────────────────────────────────┐
│  bucket-name.s3-website-region.amazonaws.com                            │
│                                                                          │
│  Settings:                                                               │
│  - Index document: index.html                                           │
│  - Error document: error.html                                           │
│  - Redirect rules (optional)                                            │
└─────────────────────────────────────────────────────────────────────────┘

Requirements:
1. Enable static website hosting
2. Disable "Block Public Access" (or use CloudFront OAI)
3. Add bucket policy for public read

Production Setup:
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Route 53  │───▶│ CloudFront  │───▶│     S3      │
│  (domain)   │    │   (CDN)     │    │  (origin)   │
└─────────────┘    └─────────────┘    └─────────────┘

Benefits of CloudFront:
- HTTPS support (S3 website is HTTP only)
- Custom domain with SSL
- Caching at edge
- Origin Access Identity (no public bucket needed)
```

---

## Pre-signed URLs

### Use Cases

```
Pre-signed URLs = Temporary access to private objects

Use Cases:
1. Direct upload from browser (bypass your server)
2. Share private files temporarily
3. Large file downloads without streaming through app

// Generate pre-signed URL (AWS SDK)
const command = new GetObjectCommand({
  Bucket: 'my-bucket',
  Key: 'private/file.pdf'
});

const url = await getSignedUrl(s3Client, command, {
  expiresIn: 3600  // 1 hour
});

// URL contains signature and expiration
// https://bucket.s3.amazonaws.com/file.pdf?X-Amz-Signature=...&X-Amz-Expires=3600

// Pre-signed POST (for uploads with conditions)
const { url, fields } = await createPresignedPost(s3Client, {
  Bucket: 'my-bucket',
  Key: 'uploads/${filename}',
  Conditions: [
    ['content-length-range', 0, 10485760],  // Max 10MB
    ['starts-with', '$Content-Type', 'image/']
  ],
  Expires: 600
});
```

---

## S3 Select & Glacier Select

```
S3 Select = Query data in place (no full download)

Supported Formats:
- CSV, JSON, Parquet
- GZIP, BZIP2 compression

Example Query:
SELECT s.name, s.age
FROM S3Object s
WHERE s.age > 25

Benefits:
- Up to 400% faster
- Up to 80% cheaper
- Filter at storage layer

Use Cases:
- Log analysis
- Large CSV/JSON processing
- Data lake queries (before full ETL)

// AWS SDK
const params = {
  Bucket: 'my-bucket',
  Key: 'data.csv',
  ExpressionType: 'SQL',
  Expression: 'SELECT * FROM s3object WHERE age > 25',
  InputSerialization: { CSV: { FileHeaderInfo: 'USE' }},
  OutputSerialization: { JSON: {} }
};
```

---

## Interview Discussion Points

### How do you secure S3 buckets?

```
Defense in Depth:

1. Account Level
   - Enable S3 Block Public Access (account-wide)
   - Use AWS Organizations SCP to prevent public buckets

2. Bucket Level
   - Block Public Access settings
   - Bucket policy (explicit denies)
   - Enable versioning + MFA delete
   - Enable access logging

3. Object Level
   - Server-side encryption (SSE-KMS for audit)
   - Object Lock for WORM compliance

4. Network Level
   - VPC endpoints (no internet traffic)
   - Bucket policies restricting to VPC

5. Monitoring
   - CloudTrail for API calls
   - S3 Access Logs for object access
   - Macie for sensitive data detection
   - Config rules for compliance
```

### How do you optimize S3 costs?

```
1. Storage Class Selection
   - Use lifecycle policies aggressively
   - Intelligent-Tiering for unknown patterns
   - Move to Glacier for archives

2. Request Optimization
   - Use CloudFront to cache reads
   - Batch small objects
   - Use S3 Select vs full downloads

3. Data Transfer
   - VPC endpoints (free within region)
   - Same-region access when possible
   - CloudFront often cheaper than S3 egress

4. Clean Up
   - Lifecycle rules to expire old objects
   - Delete incomplete multipart uploads
   - Monitor with S3 Storage Lens

5. Analysis Tools
   - S3 Storage Lens for visibility
   - Cost allocation tags
   - S3 Analytics for class recommendations
```

### How do you handle S3 for multi-region applications?

```
Option 1: Cross-Region Replication (CRR)
- Active-passive or active-active
- Eventual consistency (or RTC for 15 min SLA)
- Great for DR and read performance

Option 2: CloudFront with S3 Origin
- Single bucket, global distribution
- Caching reduces origin requests
- Good for read-heavy workloads

Option 3: Multi-Region Access Points
- Single endpoint, routes to nearest bucket
- Automatic failover
- Simplified multi-region architecture

Decision Factors:
- Write patterns (where do writes happen?)
- Consistency requirements
- Cost (replication vs CDN)
- Compliance (data residency)
```

### Explain S3 consistency model

```
S3 Consistency (current - since Dec 2020):
- Strong read-after-write consistency for all operations
- PUT, DELETE immediately visible to subsequent reads
- LIST immediately reflects changes

This means:
✓ Write object → Read immediately → Get new version
✓ Delete object → Read immediately → Get 404
✓ Overwrite object → Read immediately → Get new version

No more eventual consistency concerns for:
- New objects (was always consistent)
- Overwrites (now consistent)
- Deletes (now consistent)
- List operations (now consistent)
```
