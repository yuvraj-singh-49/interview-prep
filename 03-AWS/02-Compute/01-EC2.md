# EC2 (Elastic Compute Cloud)

## Instance Types

### Instance Family Overview

```
Instance Type: [Family][Generation][Additional Capabilities].[Size]

Example: m5a.2xlarge
         │││ │
         │││ └── Size (2xlarge = 8 vCPU, 32GB RAM)
         ││└──── Additional: 'a' = AMD, 'd' = NVMe SSD, 'n' = network optimized
         │└───── Generation: 5th gen
         └────── Family: m = general purpose
```

### Instance Families

| Family | Optimized For | Use Cases |
|--------|---------------|-----------|
| **M** (General) | Balanced | Web servers, small DBs, dev environments |
| **C** (Compute) | CPU | Batch processing, ML inference, gaming |
| **R** (Memory) | RAM | In-memory DBs, real-time analytics |
| **X** (Memory) | Extreme RAM | SAP HANA, large in-memory DBs |
| **I** (Storage) | Local NVMe | NoSQL DBs, data warehousing |
| **D** (Dense Storage) | HDD storage | Hadoop, distributed file systems |
| **G/P** (GPU) | Graphics/GPU | ML training, video encoding |
| **T** (Burstable) | Variable CPU | Low-cost, variable workloads |
| **Mac** | macOS | iOS/macOS development |

### Common Instance Sizes

```
┌────────────────────────────────────────────────────────────────────────┐
│                     Instance Size Progression                           │
├──────────┬──────────┬──────────┬──────────────────────────────────────┤
│  Size    │  vCPU    │  Memory  │  Network                             │
├──────────┼──────────┼──────────┼──────────────────────────────────────┤
│  nano    │    1     │  0.5 GB  │  Low                                 │
│  micro   │    1     │  1 GB    │  Low                                 │
│  small   │    1     │  2 GB    │  Low to Moderate                     │
│  medium  │    2     │  4 GB    │  Moderate                            │
│  large   │    2     │  8 GB    │  Moderate                            │
│  xlarge  │    4     │  16 GB   │  Moderate                            │
│  2xlarge │    8     │  32 GB   │  High                                │
│  4xlarge │   16     │  64 GB   │  High                                │
│  metal   │  Full    │  Full    │  Maximum (bare metal)                │
└──────────┴──────────┴──────────┴──────────────────────────────────────┘
```

---

## Purchasing Options

### Comparison

| Option | Discount | Commitment | Best For |
|--------|----------|------------|----------|
| **On-Demand** | 0% | None | Variable, unpredictable |
| **Reserved (1yr)** | ~40% | 1 year | Steady-state workloads |
| **Reserved (3yr)** | ~60% | 3 years | Long-term, predictable |
| **Savings Plans** | Up to 72% | $/hour commitment | Flexible workloads |
| **Spot** | Up to 90% | None (can be interrupted) | Fault-tolerant, flexible |
| **Dedicated Host** | Premium | Optional | Licensing, compliance |

### Spot Instances

```
Spot Instance Lifecycle:
┌─────────────────────────────────────────────────────────────────────────┐
│  1. Request spot instance with max price                                │
│  2. If spot price < max price → instance runs                          │
│  3. If spot price > max price → 2-minute warning → termination         │
└─────────────────────────────────────────────────────────────────────────┘

Best Practices:
- Use for fault-tolerant workloads (batch, CI/CD, big data)
- Diversify across instance types and AZs
- Use Spot Fleet for automatic management
- Implement graceful shutdown handling
- Combine with On-Demand in ASG (mixed instances)

// Spot interruption handling
curl -s http://169.254.169.254/latest/meta-data/spot/instance-action
```

### Reserved Instance Types

```
Standard RI:
- Specific instance type, AZ, tenancy
- Can sell on marketplace
- 40-60% discount

Convertible RI:
- Can change instance family, OS, tenancy
- Cannot sell on marketplace
- 30-54% discount

Savings Plans:
- Compute SP: Any instance family, region, OS
- EC2 SP: Specific instance family in a region
- More flexible than RIs
```

---

## Storage Options

### EBS Volume Types

| Type | IOPS | Throughput | Use Case |
|------|------|------------|----------|
| **gp3** | 16,000 | 1,000 MB/s | General purpose (recommended) |
| **gp2** | 16,000 | 250 MB/s | General purpose (legacy) |
| **io2** | 256,000 | 4,000 MB/s | Critical databases, high IOPS |
| **io1** | 64,000 | 1,000 MB/s | Databases (legacy) |
| **st1** | 500 | 500 MB/s | Big data, throughput-intensive |
| **sc1** | 250 | 250 MB/s | Infrequent access, lowest cost |

### Instance Store vs EBS

```
Instance Store (Ephemeral):
+ Very high IOPS (millions)
+ Included in instance price
+ Zero latency
- Data lost on stop/terminate
- Cannot detach/reattach
- Limited to instance lifetime

EBS (Persistent):
+ Data persists independently
+ Snapshots for backup
+ Can detach/reattach
+ Encryption at rest
- Network attached (latency)
- Additional cost
```

---

## Networking

### ENI, ENA, EFA

```
ENI (Elastic Network Interface):
- Virtual network card
- Private/public IP, MAC address
- Security groups attached here
- Can attach multiple ENIs

ENA (Enhanced Networking Adapter):
- Higher bandwidth (up to 100 Gbps)
- Lower latency
- Lower jitter
- Requires driver support

EFA (Elastic Fabric Adapter):
- For HPC workloads
- OS-bypass for low latency
- MPI, NCCL support
```

### Placement Groups

```
Cluster:
┌─────────────────────────────────────────┐
│  Single AZ, low-latency networking      │
│  ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐        │
│  │ i │ │ i │ │ i │ │ i │ │ i │        │
│  └───┘ └───┘ └───┘ └───┘ └───┘        │
│  Best for: HPC, tightly coupled apps    │
└─────────────────────────────────────────┘

Spread:
┌─────────────────────────────────────────┐
│  Different racks (max 7 per AZ)         │
│  ┌───┐    ┌───┐    ┌───┐               │
│  │ i │    │ i │    │ i │               │
│  └─┬─┘    └─┬─┘    └─┬─┘               │
│  Rack 1   Rack 2   Rack 3              │
│  Best for: Critical instances, HA       │
└─────────────────────────────────────────┘

Partition:
┌─────────────────────────────────────────┐
│  Logical partitions on separate racks   │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐   │
│  │ Part 1  │ │ Part 2  │ │ Part 3  │   │
│  │ ┌─┐ ┌─┐ │ │ ┌─┐ ┌─┐ │ │ ┌─┐ ┌─┐ │   │
│  │ │i│ │i│ │ │ │i│ │i│ │ │ │i│ │i│ │   │
│  └─────────┘ └─────────┘ └─────────────┘   │
│  Best for: Hadoop, Kafka, Cassandra     │
└─────────────────────────────────────────┘
```

---

## Auto Scaling

### Auto Scaling Components

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Auto Scaling Group (ASG)                          │
├─────────────────────────────────────────────────────────────────────────┤
│  Launch Template/Configuration                                           │
│  ├── AMI ID                                                             │
│  ├── Instance type                                                      │
│  ├── Key pair                                                           │
│  ├── Security groups                                                    │
│  ├── User data                                                          │
│  └── IAM instance profile                                               │
├─────────────────────────────────────────────────────────────────────────┤
│  Scaling Configuration                                                   │
│  ├── Minimum capacity: 2                                                │
│  ├── Maximum capacity: 10                                               │
│  ├── Desired capacity: 4                                                │
│  └── Health check type: ELB/EC2                                         │
├─────────────────────────────────────────────────────────────────────────┤
│  Scaling Policies                                                        │
│  ├── Target Tracking: CPU at 50%                                        │
│  ├── Step Scaling: If CPU > 80%, add 2                                  │
│  └── Scheduled: Scale up at 9am weekdays                                │
└─────────────────────────────────────────────────────────────────────────┘
```

### Scaling Policies

```python
# Target Tracking (Recommended)
# Automatically adjusts to maintain metric at target
{
    "TargetTrackingScalingPolicyConfiguration": {
        "TargetValue": 50.0,
        "PredefinedMetricSpecification": {
            "PredefinedMetricType": "ASGAverageCPUUtilization"
        }
    }
}

# Step Scaling
# Define steps based on CloudWatch alarms
{
    "AdjustmentType": "ChangeInCapacity",
    "StepAdjustments": [
        {"MetricIntervalLowerBound": 0, "MetricIntervalUpperBound": 20, "ScalingAdjustment": 1},
        {"MetricIntervalLowerBound": 20, "ScalingAdjustment": 2}
    ]
}

# Scheduled Scaling
# Time-based scaling
{
    "ScheduledActionName": "scale-out-morning",
    "Recurrence": "0 9 * * MON-FRI",
    "MinSize": 5,
    "DesiredCapacity": 8
}

# Predictive Scaling
# ML-based forecasting
{
    "PredictiveScalingConfiguration": {
        "MetricSpecifications": [...],
        "Mode": "ForecastAndScale"
    }
}
```

### Mixed Instances Policy

```json
{
  "LaunchTemplate": {
    "LaunchTemplateSpecification": {
      "LaunchTemplateId": "lt-xxx",
      "Version": "$Latest"
    },
    "Overrides": [
      {"InstanceType": "c5.large"},
      {"InstanceType": "c5a.large"},
      {"InstanceType": "c5n.large"},
      {"InstanceType": "c4.large"}
    ]
  },
  "InstancesDistribution": {
    "OnDemandBaseCapacity": 2,
    "OnDemandPercentageAboveBaseCapacity": 30,
    "SpotAllocationStrategy": "capacity-optimized"
  }
}
```

---

## AMI (Amazon Machine Image)

### AMI Components

```
AMI Contents:
┌─────────────────────────────────────────────────────────────────────────┐
│  Root Volume Template (EBS snapshot or instance store)                   │
│  Launch Permissions (who can use the AMI)                               │
│  Block Device Mapping (volumes to attach)                               │
└─────────────────────────────────────────────────────────────────────────┘

AMI Types:
1. Amazon Linux 2 / Amazon Linux 2023
2. Ubuntu, RHEL, SUSE, Windows
3. Custom AMIs (your golden images)
4. AWS Marketplace AMIs
5. Community AMIs
```

### AMI Best Practices

```
Golden AMI Strategy:
1. Start with base AMI (Amazon Linux 2)
2. Install common packages, agents
3. Harden security (CIS benchmarks)
4. Configure logging/monitoring
5. Create AMI
6. Version and tag appropriately
7. Automate with EC2 Image Builder

AMI Lifecycle:
- Deprecate old AMIs (set deprecation date)
- Deregister unused AMIs
- Delete associated snapshots
- Track AMI usage across accounts
```

---

## User Data & Metadata

### User Data

```bash
#!/bin/bash
# User data script (runs on first boot)

# Update system
yum update -y

# Install packages
yum install -y httpd

# Start service
systemctl start httpd
systemctl enable httpd

# Download app
aws s3 cp s3://my-bucket/app.zip /var/www/html/
unzip /var/www/html/app.zip -d /var/www/html/
```

### Instance Metadata Service (IMDS)

```bash
# IMDSv2 (recommended - requires session token)
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" \
  -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")

curl -H "X-aws-ec2-metadata-token: $TOKEN" \
  http://169.254.169.254/latest/meta-data/

# Common metadata endpoints
/meta-data/instance-id
/meta-data/instance-type
/meta-data/local-ipv4
/meta-data/public-ipv4
/meta-data/iam/security-credentials/role-name
/meta-data/placement/availability-zone
/user-data
```

---

## Interview Discussion Points

### How do you choose instance type?

```
1. Understand workload characteristics
   - CPU-bound → C family
   - Memory-bound → R/X family
   - Storage-bound → I/D family
   - General → M family
   - Variable/bursty → T family

2. Right-sizing process
   - Start with estimate
   - Monitor CloudWatch metrics
   - Use Compute Optimizer recommendations
   - Resize based on actual usage

3. Consider:
   - Spot eligibility
   - Reserved capacity for baseline
   - Savings Plans for flexibility
```

### How do you design for high availability?

```
1. Multi-AZ deployment
   - ASG across 3+ AZs
   - ALB distributes traffic

2. Health checks
   - ELB health checks (not just EC2)
   - Custom health check endpoints

3. Graceful handling
   - Connection draining
   - Lifecycle hooks for cleanup

4. Stateless design
   - No local state (use S3, DynamoDB)
   - Session in ElastiCache

5. Auto recovery
   - ASG replaces unhealthy instances
   - EC2 auto recovery for hardware failures
```

### How do you handle a Spot interruption?

```
1. Detection
   - Poll metadata endpoint for interruption notice
   - Use EventBridge for Spot interruption events

2. Graceful shutdown
   - Finish current work or checkpoint
   - Drain connections
   - Deregister from load balancer

3. Architecture
   - Checkpointing for long-running jobs
   - Diversify instance types
   - Mix with On-Demand (ASG mixed instances)

4. Recovery
   - ASG launches replacement
   - Stateless design resumes work
```
